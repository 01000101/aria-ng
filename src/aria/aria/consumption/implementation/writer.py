
from ... import VERSION, make_agnostic
from cStringIO import StringIO
import datetime, re

def one_line(value):
    return value.strip().replace('\n', '; ')

def translate_assignment(a):
    if isinstance(a, dict):
        for k, v in a.iteritems():
            if k == 'get_input':
                return '$$context.service.%s$$' % v
            elif k == 'get_property':
                return '$$self.%s$$' % '.'.join(v)
            else:
                a[k] = translate_assignment(v)
    return a

def unquote_tokens(v):
    return re.sub(r'(\'\$\$|\$\$\')', '', v)

def repr_assignment(a):
    return unquote_tokens(repr(translate_assignment(make_agnostic(a))))

def create_header():
    with Writer() as w:
        w.write('"""')
        w.write('Generated by ARIA version %s on %s' % (VERSION, datetime.datetime.utcnow()))
        w.write('"""')
        w.write()
        w.put('from aria import has_validated_properties, validated_property, property_type, property_default, property_status, required_property, has_interfaces, interfacemethod')
        return str(w)

class Writer(object):
    """
    A friendly wrapper over StringIO that supports Python's "with" keyword,
    indentation, and more.
    """
    def __init__(self):
        self.indent = 0

    def put_indent(self):
        if self.indent:
            for _ in range(self.indent):
                self.io.write('    ')
    
    def put(self, s=None):
        if s is not None:
            self.io.write(str(s))
    
    def write(self, s=None, prefix=None):
        if s is not None:
            for s in str(s).split('\n'):
                self.put_indent()
                if prefix is not None:
                    self.io.write(prefix)
                self.io.write(s)
                self.io.write('\n')
        else:
            self.io.write('\n')
    
    def write_docstring(self, s):
        self.write('"""')
        self.write(s.strip())
        self.write('"""')
    
    def i(self):
        self.indent += 1
    
    def o(self):
        self.indent -= 1
    
    def __enter__(self):
        self.io = StringIO()
        return self
        
    def __exit__(self, type, value, traceback):
        self.io.close()
        
    def __str__(self):
        return self.io.getvalue()
