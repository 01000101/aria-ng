
from aria import make_agnostic
from consumer import Consumer
from cStringIO import StringIO
from collections import OrderedDict
from clint.textui import puts, colored, indent
import json, os, os.path, sys, re, inspect, datetime

def one_line(value):
    return value.strip().replace('\n', '; ')

def translate_assignment(a):
    if isinstance(a, dict):
        for k, v in a.iteritems():
            if k == 'get_input':
                return '$$context.profile.%s$$' % v
            elif k == 'get_property':
                return '$$self.%s$$' % '.'.join(v)
            else:
                a[k] = translate_assignment(v)
    return a

def unquote_tokens(v):
    return re.sub(r'(\'\$\$|\$\$\')', '', v)

def repr_assignment(a):
    return unquote_tokens(repr(translate_assignment(make_agnostic(a))))

def create_header():
    with Writer() as w:
        w.write('"""')
        w.write('Generated by ARIA on %s' % datetime.datetime.utcnow())
        w.write('"""')
        w.write()
        w.put('from aria import has_validated_properties, validated_property, property_type, property_default, property_status, required_property, has_interfaces, interfacemethod')
        return str(w)

class Writer(object):
    def __init__(self):
        self.indent = 0

    def put_indent(self):
        if self.indent:
            for i in range(self.indent):
                self.io.write('    ')
    
    def put(self, s=None):
        if s is not None:
            self.io.write(str(s))
    
    def write(self, s=None, prefix=None):
        if s is not None:
            for s in str(s).split('\n'):
                self.put_indent()
                if prefix is not None:
                    self.io.write(prefix)
                self.io.write(s)
                self.io.write('\n')
        else:
            self.io.write('\n')
    
    def write_docstring(self, s):
        self.write('"""')
        self.write(s)
        self.write('"""')
    
    def i(self):
        self.indent += 1
    
    def o(self):
        self.indent -= 1
    
    def __enter__(self):
        self.io = StringIO()
        return self
        
    def __exit__(self, type, value, traceback):
        self.io.close()
        
    def __str__(self):
        return self.io.getvalue()

class CodeModule(object):
    def __init__(self, generator, name='', parent=None):
        self.generator = generator
        self.name = name
        self.parent = parent
        self.children = {}
        self.classes = OrderedDict()
    
    def get_module(self, name, create=True):
        if name is None:
            return self
            
        if '.' in name:
            name, remainder = name.split('.', 1)
            m = self.get_module(name)
            return m.get_module(remainder)
        
        for n, m in self.children.iteritems():
            if n == name:
                return m
        
        if create:
            m = CodeModule(self.generator, name, self)
            self.children[name] = m
            return m
        
        return None
    
    def get_class(self, name, create=True):
        if name in self.classes:
            return self.classes[name]
        if create:
            c = CodeClass(self.generator, name, module=self)
            self.classes[name] = c
            return c
        return None
    
    def find_class(self, name, create=True):
        module = None
        if '.' in name:
            module, name = name.rsplit('.', 1)
        module = self.get_module(module, create)
        return module.get_class(name, create) if module else None
    
    def sort_classes(self):
        class Wrapper(object):
            def __init__(self, cls):
                self.cls = cls
            def __cmp__(self, o):
                if (self.cls.module == o.cls.module):
                    if (self.cls.base == o.cls):
                        return 1
                    elif (o.cls.base == self.cls):
                        return -1
                return 0
                
        def key((_, c)):
            return Wrapper(c)
        
        items = self.classes.items()
        items.sort(key=key)
        self.classes = OrderedDict(items)

    @property
    def all_modules(self):
        yield self
        for m in self.children.itervalues():
            for m in m.all_modules:
                yield m

    @property
    def all_classes(self):
        for c in self.classes.itervalues():
            yield c
        for m in self.children.itervalues():
            for c in m.all_classes:
                yield c

    @property
    def fullname(self):
        n = self.parent.fullname if self.parent else ''
        return '%s.%s' % (n, self.name) if n else self.name
    
    @property
    def path(self):
        p = self.parent.path if self.parent else ''
        return os.path.join(p, self.name) if p else self.name
    
    @property
    def file(self):
        f = self.parent.path if self.parent else ''
        if self.children:
            if self.name:
                f = os.path.join(f, self.name)
            f = os.path.join(f, '__init__.py')
        else:
            f = os.path.join(f, self.name + '.py')
        return f
    
    def __str__(self):
        self.sort_classes()
        with Writer() as w:
            w.write(create_header())
            imports = set()
            for c in self.classes.itervalues():
                if (c.base != 'object') and (c.base.module != self):
                    imports.add(c.base.module.fullname)
            for i in imports:
                w.write('import %s' % i)
            w.write()
            for c in self.classes.itervalues():
                w.write(str(c))
            if self.children:
                all = [m.name for m in self.children.itervalues()]
                all += [c.name for c in self.classes.itervalues()]
                w.write('__all__ = %s' % repr(all))
            return str(w)

class CodeClass(object):
    def __init__(self, generator, name, module=None, base='object', description=None):
        self.generator = generator
        self.name = name
        self.module = module
        self.base = base
        self.description = description
        self.properties = OrderedDict()
        self.methods = OrderedDict()
    
    @property
    def fullname(self):
        return '%s.%s' % (self.module.fullname, self.name)
    
    def make_names_unique(self):
        names = []
        def unique_name(name):
            if name not in names:
                names.append(name)
                return name
            else:
                return unique_name(name + '_')
        
        for m in self.methods.itervalues():
            m.name = unique_name(m.name)
    
    def __str__(self):
        self.make_names_unique()

        with Writer() as w:
            w.write('@has_validated_properties')
            w.write('@has_interfaces')
            base = self.base if isinstance(self.base, str) else (self.base.name if self.base.module == self.module else self.base.fullname)
            w.write('class %s(%s):' % (self.name, base))
            w.i()
            if self.description:
                w.write_docstring(self.description)
            w.write('def __init__(self, context):')
            w.i()
            w.write('self.context = context')
            w.o()
            for n, p in self.properties.iteritems():
                w.write()
                if p.default is not None:
                    w.write('@property_default(%s)' % repr(make_agnostic(p.default)))
                if p.type:
                    w.write('#@property_type(%s)' % self.generator.get_classname(p.type))
                w.write('@validated_property')
                w.write('def %s(self):' % n)
                w.i()
                if p.description:
                    w.write('"""')
                    w.write(p.description)
                    if p.type is not None:
                        w.write(':rtype: :class:`%s`' % self.generator.get_classname(p.type))
                    w.write('"""')
                else:
                    w.write('pass')
                w.o()
            for n, m in self.methods.iteritems():
                w.write()
                w.write(m)
            return str(w)

class CodeProperty(object):
    def __init__(self, generator, name, description=None, type=None, default=None):
        self.generator = generator
        self.name = name
        self.description = description
        self.type = type
        self.default = default

    @property
    def docstring(self):
        with Writer() as w:
            w.put(':param')
            if self.type:
                w.put(' %s' % self.type)
            w.put(' %s: %s' % (self.name, one_line(self.description or self.name)))
            return str(w)
    
    @property
    def signature(self):
        with Writer() as w:
            w.put('%s' % self.name)
            if self.default is not None:
                w.put('=%s' % repr(make_agnostic(self.default)))
            return str(w)

class CodeAssignment(object):
    def __init__(self, generator, name, description, value):
        self.generator = generator
        self.name = name
        self.description = description
        self.value = value

class CodeMethod(object):
    def __init__(self, generator, name, interface, implementation, executor):
        self.generator = generator
        self.name = name
        self.interface = interface
        self.implementation = implementation
        self.executor = executor
        self.arguments = OrderedDict()
    
    def __str__(self):
        with Writer() as w:
            w.write('@interfacemethod(%s)' % repr(self.interface))
            w.put('def %s(self' % self.name)
            if self.arguments:
                for a in self.arguments.itervalues():
                    w.put(', %s' % a.signature)
            w.put('):\n')
            w.i()
            if self.arguments:
                w.write('"""')
                for n, a in self.arguments.iteritems():
                    w.write(a.docstring)
                w.write('"""')
            w.put_indent()
            if self.implementation:
                if self.executor:
                    w.put('self.context.executor(%s).' % repr(self.executor))
                else:
                    w.put('self.context.')
                if '/' in self.implementation:
                    w.put('execute(self, %s' % repr(self.implementation))
                else:
                    w.put('%s(self' % self.implementation)
                if self.arguments:
                    for n in self.arguments:
                        w.put(', %s' % n)
                w.put(')')
            else:
                w.put('pass')
            return str(w)

class CodeNodeTemplate(object):
    def __init__(self, generator, name, type, description):
        self.generator = generator
        self.name = name
        self.type = type
        self.description = description
        self.assignments = OrderedDict()
        self.relationships = []
        
    def relate(self, w):
        if self.relationships:
            for r in self.relationships:
                w.write('context.relate(self.%s, %s(context), self.%s)' % (self.name, self.generator.get_classname(r.type), r.target))
    
    def __str__(self):
        with Writer() as w:
            if self.description:
                w.write('%s' % self.description, prefix='# ')
            w.write('self.%s = %s(context)' % (self.name, self.generator.get_classname(self.type)))
            if self.assignments:
                for k, v in self.assignments.iteritems():
                    w.write('self.%s.%s = %s' % (self.name, k, repr_assignment(v)))
            return str(w)

class CodeRelationship(object):
    def __init__(self, generator, type, target):
        self.generator = generator
        self.type = type
        self.target = target

class CodeGenerator(object):
    def __init__(self):
        self.description = None
        self.module = CodeModule(self)
        self.inputs = OrderedDict()
        self.outputs = OrderedDict()
        self.nodes = OrderedDict()
        self.translate_classes = {}
        self.common_module_name = 'common'
    
    def get_class(self, name, create=True):
        return self.module.find_class(name, create)

    def get_classname(self, name):
        if name in self.translate_classes:
            return self.translate_classes[name].fullname
        return name

    def link_classes(self):
        for c in self.module.all_classes:
            if isinstance(c.base, str):
                b = self.get_class(c.base, False)
                if b:
                    c.base = b
        for c in self.module.all_classes:
            if not c.module.name:
                del c.module.classes[c.name]
                root = self.module.get_module(self.common_module_name)
                c.module = root
                root.classes[c.name] = c
                self.translate_classes[c.name] = c
    
    def write_file(self, file, content):
        try:
            os.makedirs(os.path.dirname(file))
        except OSError as e:
            if e.errno != 17:
                raise e
        with open(file, 'w') as f:
            f.write(str(content))
    
    def write(self, root):
        self.link_classes()
        for m in self.module.all_modules:
            if m.name:
                file = os.path.join(root, m.file)
                self.write_file(file, m)
        file = os.path.join(root, 'blueprint.py')
        self.write_file(file, self.blueprint)

    @property
    def blueprint(self):
        with Writer() as w:
            w.write(create_header())
            for m in self.module.all_modules:
                if m.fullname:
                    w.write('import %s' % m.fullname)
            w.write()
            w.write('class Blueprint(object):')
            w.i()
            if self.description or self.inputs:
                w.write('"""')
                if self.description:
                    w.write(self.description)
                if self.inputs:
                    for i in self.inputs.itervalues():
                        w.write(i.docstring)
                w.write('"""')
            w.put_indent()
            w.put('def __init__(self, context')
            if self.inputs:
                for i in self.inputs.itervalues():
                    w.put(', %s' % i.signature)
            w.put('):\n')
            w.i()
            w.write('self.context = context')
            w.write('self.context.profile = self')
            if self.inputs:
                w.write()
                w.write('# Inputs')
                for i in self.inputs:
                    w.write('self.%s = %s' % (i, i))
            if self.nodes:
                w.write()
                for n in self.nodes.itervalues():
                    w.write(n.description or 'Node template: %s' % n.name, prefix='# ')
                    w.write(n)
                w.write('# Relationships')
                for n in self.nodes.itervalues():
                    n.relate(w)
            w.o()
            if self.outputs:
                for o in self.outputs.itervalues():
                    w.write()
                    w.write('@property')
                    w.write('def %s(self):' % o.name)
                    w.i()
                    if o.description:
                        w.write_docstring(o.description)
                    w.write('return %s' % repr_assignment(o.value))
                    w.o()
            return str(w)

class Context(object):
    def __init__(self):
        self.profile = None
    
    def relate(self, source, relationship, target):
        pass

class Implementer(Consumer):
    """
    ARIA implementer.
    
    Creates Python classes for the presentation.
    """

    def __init__(self, presentation, args=[], root='out'):
        super(Implementer, self).__init__(presentation, args)
        self.root = root

    def consume(self):
        self.generate()
        print self.blueprint
    
    @property
    def blueprint(self):
        sys.path.append(self.root)
        from blueprint import Blueprint
        args = len(inspect.getargspec(Blueprint.__init__).args) - 2
        context = Context()
        blueprint = Blueprint(context, *([None] * args))
        return blueprint

    def generate(self):
        profile = self.presentation.profile
        
        generator = CodeGenerator()
        
        generator.description = profile.description
        
        if profile.node_types:
            for name, node_type in profile.node_types.iteritems():
                cls = generator.get_class(name)
                if node_type.derived_from:
                    cls.base = node_type.derived_from
                if node_type.description:
                    cls.description = node_type.description
                if node_type.properties:
                    for name, p in node_type.properties.iteritems():
                        cls.properties[name] = CodeProperty(generator, name, p.description, p.type, p.default)
                if node_type.interfaces:
                    for name, i in node_type.interfaces.iteritems():
                        for wname, w in i.workflows.iteritems():
                            method = CodeMethod(generator, wname, name, w.implementation, w.executor)
                            cls.methods[wname] = method
                            if w.inputs:
                                for pname, p in w.inputs.iteritems():
                                    method.arguments[pname] = CodeProperty(generator, pname, p.description, p.type, p.default)

        if profile.relationships:
            for name, relationship in profile.relationships.iteritems():
                cls = generator.get_class(name)
                if relationship.derived_from:
                    cls.base = relationship.derived_from
                if relationship.description:
                    cls.description = relationship.description
                if relationship.properties:
                    for name, p in relationship.properties.iteritems():
                        cls.properties[name] = CodeProperty(generator, name, p.description, p.type, p.default)

        if profile.inputs:
            for name, input in profile.inputs.iteritems():
                generator.inputs[name] = CodeProperty(generator, name, input.description, input.type, input.default)

        if profile.outputs:
            for name, output in profile.outputs.iteritems():
                generator.outputs[name] = CodeAssignment(generator, name, output.description, output.value)
        
        if profile.node_templates:
            for name, node in profile.node_templates.iteritems():
                n = CodeNodeTemplate(generator, name, node.type, node.description)
                generator.nodes[name] = n
                if node.properties:
                    for name, p in node.properties.iteritems():
                        n.assignments[name] = p.value
                if node.relationships:
                    for r in node.relationships:
                        n.relationships.append(CodeRelationship(generator, r.type, r.target))
        
        generator.write(self.root)
        
        return generator

    def dump(self):
        generator = self.implement()
        for m in generator.module.modules:
            if m.name:
                puts(colored.red(m.file))
            with indent(2):
                for c in m.classes.itervalues():
                    puts(str(c))
